<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pac-Man (Vanilla JS)</title>
<style>
  :root{--bg:#0b1220;--panel:#0f172a;--text:#e5e7eb;--muted:#93a4b2;--accent:#ffd54a}
  html,body{height:100%}
  body{margin:0;background:radial-gradient(1000px 800px at 50% -10%,#152238 0%,#0b1220 60%,#071426 100%);color:var(--text);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;display:flex;align-items:center;justify-content:center}
  .wrap{display:grid;gap:12px;grid-template-columns:auto}
  .hud{display:flex;align-items:center;justify-content:space-between;background:#0f172a;box-shadow:0 10px 30px rgba(0,0,0,.4);border:1px solid #18263a;border-radius:12px;padding:10px 12px}
  .hud b{color:var(--accent)}
  canvas{border-radius:12px;border:1px solid #18263a;box-shadow:0 20px 50px rgba(0,0,0,.5);background:#000014;image-rendering:pixelated}
  .controls{display:flex;gap:8px;align-items:center}
  button{padding:8px 12px;border-radius:10px;border:1px solid #17304a;background:#13263c;color:var(--text);cursor:pointer}
  button:hover{border-color:#2b507a}
  .msg{min-height:20px;color:var(--muted)}
</style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div>Score: <b id="score">0</b> &nbsp; • &nbsp; Lives: <b id="lives">3</b> &nbsp; • &nbsp; Level: <b id="level">1</b></div>
      <div class="controls">
        <button id="btnStart">▶ Start</button>
        <span class="msg" id="msg">Use arrow keys / WASD</span>
      </div>
    </div>
    <canvas id="game" width="608" height="672" aria-label="Pac-Man game" tabindex="0"></canvas>
  </div>

<script>
// ===== PAC-MAN: Vanilla JS, Canvas, Single File (Slower Pace) =====
const TILE = 32;
const COLS = 19, ROWS = 21;
const W = COLS*TILE, H = ROWS*TILE;

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = W; canvas.height = H;

const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');
const levelEl = document.getElementById('level');
const msgEl = document.getElementById('msg');

// Map legend: 0 wall, 1 pellet, 2 empty, 3 power, 4 ghostDoor, 5 tunnel (empty)
const BASE_MAP = [
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,0],
  [0,1,0,0,0,1,0,0,1,2,1,0,0,0,1,0,0,1,0],
  [0,3,0,2,0,1,0,2,1,1,1,2,0,2,1,0,3,1,0],
  [0,1,0,2,0,1,0,2,0,0,0,2,0,2,1,0,1,1,0],
  [0,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,0],
  [0,1,0,2,0,1,0,0,0,0,0,0,0,1,0,2,0,1,0],
  [0,1,1,2,1,1,1,2,1,5,1,2,1,1,1,2,1,1,0],
  [0,0,0,2,0,0,1,2,0,0,0,2,1,0,0,2,0,0,0],
  [0,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,0],
  [0,1,0,0,0,1,0,0,0,2,0,0,0,1,0,0,0,1,0],
  [0,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,0],
  [0,0,0,2,0,0,1,0,0,0,0,0,1,0,0,2,0,0,0],
  [0,1,1,2,1,1,1,2,1,5,1,2,1,1,1,2,1,1,0],
  [0,1,0,2,0,1,0,2,1,1,1,2,0,1,0,2,0,1,0],
  [0,3,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,3,0],
  [0,1,0,0,0,1,0,0,1,2,1,0,0,0,1,0,0,1,0],
  [0,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,0],
  [0,1,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,1,0],
  [0,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
];

function cloneMap(){ return BASE_MAP.map(r => r.slice()); }

const DIRS = {left:{x:-1,y:0}, right:{x:1,y:0}, up:{x:0,y:-1}, down:{x:0,y:1}};
const KEYS = {37:'left',38:'up',39:'right',40:'down',65:'left',87:'up',68:'right',83:'down'};

let state;
function reset(level=1){
  state = {
    map: cloneMap(),
    level,
    pellets: 0,
    score: 0,
    lives: 3,
    frightened: 60*6, // ~6s base (slower vibe)
    pac:{x:9,y:15, dir:'left', nextDir:'left'},
    ghosts:[
      {name:'Blinky', color:'#ff4b4b', x:9, y:5, dir:'left'},
      {name:'Pinky',  color:'#ff9ad5', x:9, y:6, dir:'right'},
      {name:'Inky',   color:'#6cf0ff', x:8, y:6, dir:'up'},
      {name:'Clyde',  color:'#ffb86c', x:10,y:6, dir:'down'},
    ]
  };
  state.pellets = state.map.flat().filter(v=>v===1||v===3).length;
  updateHUD();
}

function updateHUD(){
  scoreEl.textContent = state.score;
  livesEl.textContent = state.lives;
  levelEl.textContent = state.level;
}

// Map helpers
function tileAt(x,y){
  if(y<0||y>=ROWS) return 0;
  if(x<0){ if(state.map[y][1]===5) return 2; return state.map[y][0]; }
  if(x>=COLS){ if(state.map[y][COLS-2]===5) return 2; return state.map[y][COLS-1]; }
  return state.map[y][x];
}
function isWall(x,y){ return tileAt(x,y)===0 || tileAt(x,y)===4; }

function canMove(x,y,dir){
  const nx=x+DIRS[dir].x, ny=y+DIRS[dir].y;
  return !isWall(nx,ny);
}
function stepWrap(pos){
  if(pos.x<0) pos.x=COLS-1; else if(pos.x>=COLS) pos.x=0;
}

// Input
let keysDown={};
addEventListener('keydown',e=>{ if(KEYS[e.keyCode]){ keysDown[KEYS[e.keyCode]]=true; e.preventDefault(); }});
addEventListener('keyup',e=>{ if(KEYS[e.keyCode]){ keysDown[KEYS[e.keyCode]]=false; e.preventDefault(); }});
function handleInput(){
  for(const d of ['left','right','up','down']){
    if(keysDown[d]) state.pac.nextDir=d;
  }
}

// Eat pellets / power
function eatAt(x,y){
  const t = tileAt(x,y);
  if(t===1){ state.map[y][x]=2; state.score+=10; state.pellets--; updateHUD(); }
  else if(t===3){ state.map[y][x]=2; state.score+=50; state.pellets--; state.frightened = 60*8; updateHUD(); }
}

// Slower, calmer ghost logic
function ghostStep(g){
  // pick new direction sometimes; bias toward Pac-Man
  if(Math.random()<0.06){ // fewer changes = slower feel
    const opts=['left','right','up','down'].filter(d=>canMove(g.x,g.y,d));
    if(opts.length){
      const best = opts.sort((a,b)=>distAfter(a)-distAfter(b))[0];
      g.dir = best;
    }
  }
  function distAfter(dir){
    const nx=g.x+DIRS[dir].x, ny=g.y+DIRS[dir].y;
    return Math.abs(nx-state.pac.x)+Math.abs(ny-state.pac.y);
  }
  if(!canMove(g.x,g.y,g.dir)){
    const opts=['left','right','up','down'].filter(d=>canMove(g.x,g.y,d));
    if(opts.length) g.dir = opts[Math.floor(Math.random()*opts.length)];
  }
  g.x += DIRS[g.dir].x; g.y += DIRS[g.dir].y; stepWrap(g);
}

function pacStep(){
  const p = state.pac;
  if(canMove(p.x,p.y,p.nextDir)) p.dir=p.nextDir;
  if(canMove(p.x,p.y,p.dir)){
    p.x += DIRS[p.dir].x; p.y += DIRS[p.dir].y; stepWrap(p);
  }
  eatAt(p.x,p.y);
}

function collide(a,b){ return a.x===b.x && a.y===b.y; }

function checkCollisions(){
  for(const g of state.ghosts){
    if(collide(state.pac,g)){
      if(state.frightened>0){
        state.score += 200; updateHUD();
        g.x=9; g.y=6; g.dir='up';
      }else{
        state.lives--; updateHUD();
        if(state.lives<0){ gameOver(); return; }
        state.pac.x=9; state.pac.y=15; state.pac.dir='left';
        state.ghosts.forEach((gg,i)=>{ gg.x=9+(i%2?1:-1); gg.y=6+(i>1?1:0); gg.dir='left'; });
      }
    }
  }
}

function gameOver(){ running=false; msgEl.textContent='Game Over — press Start to play again'; }
function winLevel(){ running=false; msgEl.textContent='Level cleared! Press Start'; }

// Rendering
function draw(){
  ctx.clearRect(0,0,W,H);
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      const t=tileAt(x,y), px=x*TILE, py=y*TILE;
      if(t===0||t===4){
        ctx.fillStyle='#0c2450'; ctx.fillRect(px+2,py+2,TILE-4,TILE-4);
        ctx.strokeStyle='#1e58a8'; ctx.lineWidth=2; ctx.strokeRect(px+3,py+3,TILE-6,TILE-6);
      } else {
        ctx.fillStyle='#00001a'; ctx.fillRect(px,py,TILE,TILE);
        if(t===1){ ctx.fillStyle='#ffd54a'; ctx.beginPath(); ctx.arc(px+TILE/2, py+TILE/2, 3, 0, Math.PI*2); ctx.fill(); }
        else if(t===3){ ctx.fillStyle='#ff9df5'; ctx.beginPath(); ctx.arc(px+TILE/2, py+TILE/2, 6, 0, Math.PI*2); ctx.fill(); }
      }
    }
  }
  drawPac(state.pac);
  for(const g of state.ghosts) drawGhost(g);
}

function drawPac(p){
  const x=p.x*TILE+TILE/2, y=p.y*TILE+TILE/2, r=TILE*0.38;
  const t=Date.now()/350; // slower mouth animation
  const mouth = (Math.sin(t)+1)/4 + 0.15;
  const dirAngle = {right:0,left:Math.PI,up:-Math.PI/2,down:Math.PI/2}[p.dir||'right'];
  ctx.fillStyle = '#ffd54a';
  ctx.beginPath();
  ctx.moveTo(x,y);
  ctx.arc(x,y,r, dirAngle+mouth, dirAngle-mouth, false);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = '#0b1220';
  const ex = x + Math.cos(dirAngle - Math.PI/2)*6;
  const ey = y + Math.sin(dirAngle - Math.PI/2)*6;
  ctx.beginPath(); ctx.arc(ex,ey,3,0,Math.PI*2); ctx.fill();
}

function drawGhost(g){
  const x=g.x*TILE+TILE/2, y=g.y*TILE+TILE/2, r=TILE*0.36;
  const body = state.frightened>0 ? '#4169e1' : g.color;
  ctx.fillStyle=body; ctx.beginPath();
  ctx.arc(x,y,r,Math.PI,0,false);
  ctx.lineTo(x+r, y+r);
  for(let i=0;i<5;i++){
    ctx.quadraticCurveTo(x+r-(i+0.5)*(2*r/5), y+r+6*(i%2?1:-1), x+r-(i+1)*(2*r/5), y+r);
  }
  ctx.closePath(); ctx.fill();
  ctx.fillStyle='#fff';
  for(const dx of [-8,8]){ ctx.beginPath(); ctx.arc(x+dx/2, y-2, 5, 0, Math.PI*2); ctx.fill(); }
  ctx.fillStyle='#0b1220';
  const vx=DIRS[g.dir]?.x*2||0, vy=DIRS[g.dir]?.y*2||0;
  for(const dx of [-8,8]){ ctx.beginPath(); ctx.arc(x+dx/2+vx, y-2+vy, 2.5, 0, Math.PI*2); ctx.fill(); }
}

// === Slower overall gameplay via frame throttling ===
let frame=0;
const PAC_DELAY   = 6;  // Pac-Man steps every 6 frames (~10 steps/sec at 60fps)
const GHOST_DELAY = 8;  // Ghosts step every 8 frames (~7.5 steps/sec)
let running=false;

function tick(){
  handleInput();
  if(running){
    if(frame % PAC_DELAY   === 0) pacStep();
    if(frame % GHOST_DELAY === 0) for(const g of state.ghosts) ghostStep(g);
    checkCollisions();
    if(state.frightened>0) state.frightened--;
    if(state.pellets<=0){ state.level++; reset(state.level); msgEl.textContent='Level up!'; }
    frame++;
  }
  draw();
  requestAnimationFrame(tick);
}

// Controls
function startGame(){ reset(1); running=true; msgEl.textContent=''; updateHUD(); }
function stopGame(){ running=false; msgEl.textContent='Paused'; }

document.getElementById('btnStart').addEventListener('click', startGame);

// Boot
reset(1); draw();
canvas.focus();
requestAnimationFrame(tick);
</script>
</body>
</html>
